Here is the **updated Product Requirements Document (PRD)** for your app **Breaking Changes**, now aligned with the decision to use the **latest stable version of Next.js (v14+)**, which supports **React 19** and **React Server Components (RSC)** out of the box.

---

# ğŸ“„ Product Requirements Document (PRD)

## 1. Overview

**Product Name**: Breaking Changes  
**Goal**: Help developers identify breaking changes between two release versions of a public GitHub repository.  
**Description**: Users input a GitHub repository URL, select a version range, and receive a summarized list of breaking changes generated by an LLM.  
**Tech Stack**:
- **Framework**: Next.js (v14+ stable)
- **React**: React 19 with Server Components
- **Data Fetching & Caching**: React Query (TanStack Query)
- **UI Library**: Mantine UI
- **API Integration**: GitHub REST API
- **LLM Integration**: OpenAI, Claude, or compatible provider via API route

---

## 2. Objectives

- Provide a quick, intuitive interface to explore changelogs.
- Allow users to select two versions and analyze the changelog delta.
- Surface only breaking changes using a large language model (LLM).
- Focus on developer productivity and upgrade planning.

---

## 3. Functional Requirements

### 3.1 Input

- Text field for pasting a GitHub repo URL.
- Validate and parse `owner/repo` from the input.

### 3.2 Release Fetching

- Use GitHub API to fetch all available releases:
  - Endpoint: `GET /repos/{owner}/{repo}/releases`
- Display releases sorted by publish date (newest â†’ oldest).

### 3.3 Version Selection

- Allow users to select:
  - **Current version**
  - **Target version**
- Automatically compute release range between selected versions.

### 3.4 Changelog Aggregation

- Extract `body` fields from selected releases.
- Concatenate changelogs into a single markdown string.

### 3.5 Breaking Change Detection

- Send changelog string to LLM via API route.
- Prompt model to extract and summarize breaking changes.
- Render the output in a readable format (e.g., checklist, cards).

---

## 4. Non-Functional Requirements

- Use RSC for server-side fetching of releases and SSR benefits [1][2].
- Client-side interactivity and caching via React Query.
- Responsive UI with Mantine components.
- Securely call LLM backend using Next.js API routes.
- Graceful handling of:
  - Rate limits
  - Empty/malformed changelogs
  - Invalid repo URLs

---

## 5. User Flow

```plaintext
User lands on homepage
   â†“
Pastes GitHub repo URL
   â†“
App parses owner/repo and fetches releases
   â†“
User selects current and target versions
   â†“
Changelogs between versions are aggregated
   â†“
LLM analyzes and summarizes breaking changes
   â†“
Results displayed in readable format
```

---

## 6. Edge Cases & Errors

- **Invalid URL** â†’ Show validation error.
- **Repo not found / no releases** â†’ Show fallback message.
- **Rate limit hit / API error** â†’ Notify user.
- **LLM timeout / failure** â†’ Retry or provide fallback explanation.

---

## 7. Future Enhancements

- Authenticated GitHub access for private repos.
- Export summary as Markdown or PDF.
- Inline diff view of changelog bodies.
- Save recent comparisons in browser/localStorage.
- Multi-repo tracking dashboard.

---

## 8. Milestones & Timeline

| Milestone                   | Description                                                      | ETA        |
|----------------------------|------------------------------------------------------------------|------------|
| âœ… PRD Finalized            | Updated scope and strategy using Next.js                        | Today      |
| ğŸ› ï¸ Scaffold Project        | Setup Next.js app with Mantine, React Query                     | Day 1      |
| ğŸ”Œ GitHub Release Fetching | Server Component fetch logic + URL parsing                      | Day 2      |
| ğŸ”¢ Version Selection Logic | UI + logic to identify version range                            | Day 3      |
| ğŸ§  LLM Integration         | API route to send changelog to LLM                              | Day 4      |
| ğŸ¨ Result Rendering        | Display summary from LLM in clean format                        | Day 5      |
| ğŸ§ª Error Handling          | Handle edge cases, loading states, validation                   | Day 6      |
| ğŸš€ Deploy MVP              | Deploy on Vercel with environment config for LLM/API keys       | Day 7      |

---

Below is a **detailed, test-driven implementation strategy** for building **Breaking Changes**, structured in clear, focused stages. Each stage includes:

- Feature scope
- Purpose
- Manual acceptance criteria
- Integration test ideas
- Tech notes

This approach ensures each milestone is independently testable, stable, and incrementally builds toward your MVP.

---

# ğŸ§± Implementation Strategy for *Breaking Changes*

---

## **Stage 1: Project Setup**

### ğŸ”§ Scope

- Scaffold project using `create-next-app` with TypeScript and PNPM
- Configure Mantine UI and React Query
- Setup base layout and global styles
- Initialize Git repo

### âœ… Manual Acceptance Tests

- App loads with a basic layout and header
- Mantine theme applies correctly (light/dark toggle optional)
- React Query DevTools show on dev mode

### ğŸ§ª Integration Tests

- Render root layout and assert text presence (e.g. welcome message or heading)
- Render a Mantine component and check classnames/styles

### ğŸ” Tech Notes

- Use Next.js 14+ stable (with `/app` directory)
- Add React Query provider in `layout.tsx`
- Setup ESLint, Prettier, Husky for formatting/linting

---

## **Stage 2: GitHub Repo URL Input & Parsing**

### ğŸ”§ Scope

- Add input field for GitHub repo URL
- Parse `owner/repo` from the URL
- Validate input format

### âœ… Manual Acceptance Tests

- User pastes valid GitHub URL â†’ gets parsed correctly
- Invalid URL â†’ shows inline error
- Edge case: trailing slash or `.git` suffix handled

### ğŸ§ª Integration Tests

- Test parsing logic with various URL formats (unit test)
- Simulate user typing and check validation messages (RTL + Jest)

### ğŸ” Tech Notes

- Use regex or URL constructor to extract `owner/repo`
- Store parsed values in component state or context

---

## **Stage 3: Release Fetching via GitHub API**

### ğŸ”§ Scope

- Fetch releases using GitHub REST API
- Use React Server Component to fetch data initially
- Cache data with React Query on client

### âœ… Manual Acceptance Tests

- Valid repo â†’ releases load in descending order
- Invalid/empty repo â†’ shows error message
- Loading state visible during fetch

### ğŸ§ª Integration Tests

- Mock GitHub API response; assert releases rendered
- Test fallback UI for 404 / rate limit errors

### ğŸ” Tech Notes

- API: `GET /repos/{owner}/{repo}/releases`
- Add optional server API route for proxying if needed (rate limits)

---

## **Stage 4: Version Selection UI**

### ğŸ”§ Scope

- Let user select "Current" and "Target" version from dropdowns
- Disable invalid combinations (e.g., target older than current)

### âœ… Manual Acceptance Tests

- Dropdowns show fetched versions
- Selecting current/target marks the range clearly
- Disabled submit button unless both versions are picked

### ğŸ§ª Integration Tests

- Test dropdown interaction and state updates
- Validate logic that computes release range between versions

### ğŸ” Tech Notes

- Use Mantine `Select` or `Combobox` components
- Store version state in component or context for later use

---

## **Stage 5: Changelog Aggregation**

### ğŸ”§ Scope

- Extract release notes between selected versions
- Concatenate `body` fields into one markdown string

### âœ… Manual Acceptance Tests

- Correct number of releases aggregated based on selection
- Raw changelog preview available (optional)

### ğŸ§ª Integration Tests

- Unit test range slicing logic
- Assert markdown output includes expected tags/texts

### ğŸ” Tech Notes

- Filter releases using tag order or publish date
- Account for missing/incomplete `body` fields gracefully

---

## **Stage 6: LLM Integration (Backend)**

### ğŸ”§ Scope

- Create Next.js API route to send changelog to an LLM (e.g., OpenAI)
- Use a prompt to extract breaking changes from markdown input
- Return structured response (e.g., bullet points or markdown)

### âœ… Manual Acceptance Tests

- Selecting range and submitting triggers LLM response
- Response includes breaking changes summary
- Error message shown if LLM fails or times out

### ğŸ§ª Integration Tests

- Mock LLM request/response; assert output format
- Test API route with invalid/malformed input payloads

### ğŸ” Tech Notes

- Use `POST /api/analyze` route with `changelog` in body
- Prompt example:
  ```
  Given the following changelog markdown, extract only the breaking changes. Format them as a bullet list.
  ```

---

## **Stage 7: Result Rendering**

### ğŸ”§ Scope

- Display breaking changes summary cleanly using Mantine components
- Support copy/share/export functionality (optional)

### âœ… Manual Acceptance Tests

- LLM results appear in styled container (card, alert, markdown)
- Clean formatting of bullet points, code snippets, etc.
- Retry button available on failure

### ğŸ§ª Integration Tests

- Assert rendered HTML matches LLM output structure
- Snapshot test result component for consistency

### ğŸ” Tech Notes

- Use Mantine `Paper`, `Alert`, or `Markdown` components to display results
- Optional: add syntax highlighting with Prism.js if needed

---

## **Stage 8: Error Handling & Polishing**

### ğŸ”§ Scope

- Handle all edge cases:
  - API rate limits
  - LLM timeouts
  - Empty repo/releases
  - Network failures
  - Invalid user input
- Add loading indicators and retry mechanisms

### âœ… Manual Acceptance Tests

- All error cases show clear, friendly messages
- Loading states are visible and non-blocking
- Retry flows behave as expected without page reloads

### ğŸ§ª Integration Tests

- Simulate network/API failures; assert fallback UIs shown
- Retry button re-triggers fetch